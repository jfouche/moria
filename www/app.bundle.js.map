{"version":3,"sources":["webpack:///webpack/bootstrap c78618cd09201f24fac9","webpack:///./app/app.ts","webpack:///./app/maze.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACtCA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;;;;AChLD;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,gBAAgB;AAC3C;AACA,gCAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,WAAW;AACtC,gCAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC,wBAAwB","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c78618cd09201f24fac9","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar maze_1 = require(\"./maze\");\r\nvar game;\r\nfunction setup() {\r\n    game = new MoriaGame(8, 10, 5);\r\n    var canvas = createCanvas(game.width, game.height);\r\n    canvas.parent('game');\r\n    frameRate(10);\r\n}\r\nfunction draw() {\r\n    background(0);\r\n    game.draw();\r\n    updateInfo();\r\n}\r\nfunction updateInfo() {\r\n    var levelElt = document.getElementById(\"nLevel\");\r\n    levelElt.innerHTML = game.getLevel().toString();\r\n}\r\nfunction keyPressed() {\r\n    if (keyCode === UP_ARROW) {\r\n        game.moveHero(0);\r\n    }\r\n    else if (keyCode === DOWN_ARROW) {\r\n        game.moveHero(1);\r\n    }\r\n    else if (keyCode === LEFT_ARROW) {\r\n        game.moveHero(2);\r\n    }\r\n    else if (keyCode === RIGHT_ARROW) {\r\n        game.moveHero(3);\r\n    }\r\n}\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"UP\"] = 0] = \"UP\";\r\n    Direction[Direction[\"DOWN\"] = 1] = \"DOWN\";\r\n    Direction[Direction[\"LEFT\"] = 2] = \"LEFT\";\r\n    Direction[Direction[\"RIGHT\"] = 3] = \"RIGHT\";\r\n})(Direction || (Direction = {}));\r\nvar Offset = (function () {\r\n    function Offset(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    return Offset;\r\n}());\r\n;\r\nfunction directionOffset(dir) {\r\n    switch (dir) {\r\n        case 0:\r\n            return new Offset(0, -1);\r\n        case 1:\r\n            return new Offset(0, 1);\r\n        case 2:\r\n            return new Offset(-1, 0);\r\n        case 3:\r\n            return new Offset(1, 0);\r\n        default:\r\n            break;\r\n    }\r\n    return undefined;\r\n}\r\nvar MoriaGame = (function () {\r\n    function MoriaGame(nRows, nCols, nLevels) {\r\n        this.nRows = nRows;\r\n        this.nCols = nCols;\r\n        this.mazes = [];\r\n        for (var i = 0; i < nLevels; i++) {\r\n            this.mazes.push(maze_1.createMaze(this.nRows, this.nCols));\r\n        }\r\n        this.currentLevel = 0;\r\n        var maze = this.maze();\r\n        this.initLevel();\r\n    }\r\n    MoriaGame.prototype.getLevel = function () {\r\n        return this.currentLevel;\r\n    };\r\n    MoriaGame.prototype.initLevel = function () {\r\n        var maze = this.maze();\r\n        this.hero = new Hero(maze.upstair.col, maze.upstair.row);\r\n        maze.cell(this.hero.y, this.hero.x).visit();\r\n        this.checkVisibility();\r\n    };\r\n    MoriaGame.prototype.maze = function () {\r\n        return this.mazes[this.currentLevel];\r\n    };\r\n    MoriaGame.prototype.draw = function () {\r\n        background(0);\r\n    };\r\n    MoriaGame.prototype.moveHero = function (direction) {\r\n        if (this.canMove(direction)) {\r\n            this.hero.move(direction);\r\n            this.maze().cell(this.hero.y, this.hero.x).visit();\r\n            if (this.hero.x === this.maze().downstair.col && this.hero.y === this.maze().downstair.row) {\r\n                this.currentLevel++;\r\n                this.initLevel();\r\n            }\r\n            this.checkVisibility();\r\n        }\r\n    };\r\n    MoriaGame.prototype.canMove = function (direction) {\r\n        var cellBorders = this.maze().cell(this.hero.y, this.hero.x).borders;\r\n        return (direction === 3 && !cellBorders.E)\r\n            || (direction === 2 && !cellBorders.W)\r\n            || (direction === 0 && !cellBorders.N)\r\n            || (direction === 1 && !cellBorders.S);\r\n    };\r\n    MoriaGame.prototype.checkVisibility = function () {\r\n        var _this = this;\r\n        var x;\r\n        var y;\r\n        var cell;\r\n        var maze = this.maze();\r\n        var reset = function () {\r\n            x = _this.hero.x;\r\n            y = _this.hero.y;\r\n            cell = maze.cell(y, x);\r\n        };\r\n        var next = function () {\r\n            cell = maze.cell(y, x);\r\n            cell.visit();\r\n        };\r\n        reset();\r\n        while (!cell.borders.N) {\r\n            y -= 1;\r\n            next();\r\n        }\r\n        reset();\r\n        while (!cell.borders.E) {\r\n            x += 1;\r\n            next();\r\n        }\r\n        reset();\r\n        while (!cell.borders.S) {\r\n            y += 1;\r\n            next();\r\n        }\r\n        reset();\r\n        while (!cell.borders.W) {\r\n            x -= 1;\r\n            next();\r\n        }\r\n    };\r\n    return MoriaGame;\r\n}());\r\nexports.MoriaGame = MoriaGame;\r\nvar Hero = (function () {\r\n    function Hero(x, y) {\r\n        this._x = x;\r\n        this._y = y;\r\n    }\r\n    Object.defineProperty(Hero.prototype, \"x\", {\r\n        get: function () {\r\n            return this._x;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Hero.prototype, \"y\", {\r\n        get: function () {\r\n            return this._y;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Hero.prototype.moveTo = function (x, y) {\r\n        this._x += x;\r\n        this._y += y;\r\n    };\r\n    Hero.prototype.move = function (dir) {\r\n        var offset = directionOffset(dir);\r\n        this._x += offset.x;\r\n        this._y += offset.y;\r\n    };\r\n    return Hero;\r\n}());\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/app.ts\n// module id = 0\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction createMaze(nRows, nCols) {\r\n    var mazeGen = new detail.MazeGenerator();\r\n    return mazeGen.newMaze(nRows, nCols);\r\n}\r\nexports.createMaze = createMaze;\r\nvar detail;\r\n(function (detail) {\r\n    var Maze = (function () {\r\n        function Maze(nRows, nCols) {\r\n            this.nRows = nRows;\r\n            this.nCols = nCols;\r\n            this.grid = [];\r\n            for (var r = 0; r < this.nRows; r++) {\r\n                this.grid[r] = [];\r\n                for (var c = 0; c < this.nCols; c++) {\r\n                    this.grid[r][c] = new Cell(r, c);\r\n                }\r\n            }\r\n            this.upstair = new Stair(0, 0, true);\r\n            this.downstair = new Stair(nRows - 1, nCols - 1, false);\r\n        }\r\n        Maze.prototype.cell = function (row, col) {\r\n            return this.grid[row][col];\r\n        };\r\n        return Maze;\r\n    }());\r\n    var MazeGenerator = (function () {\r\n        function MazeGenerator() {\r\n        }\r\n        MazeGenerator.prototype.newMaze = function (nRows, nCols) {\r\n            var maze = new Maze(nRows, nCols);\r\n            var backtracking = [];\r\n            var currentCell = maze.cell(0, 0);\r\n            currentCell.visited = true;\r\n            var finished = false;\r\n            while (!finished) {\r\n                var next = this.getNextNeighbor(maze, currentCell);\r\n                if (next) {\r\n                    next.visited = true;\r\n                    backtracking.push(currentCell);\r\n                    this.removeWallsBetween(currentCell, next);\r\n                    currentCell = next;\r\n                }\r\n                else if (backtracking.length > 0) {\r\n                    next = backtracking.pop();\r\n                    currentCell = next;\r\n                }\r\n                else {\r\n                    console.log(\"FINISH\");\r\n                    finished = true;\r\n                }\r\n            }\r\n            for (var r = 0; r < nRows; r++) {\r\n                for (var c = 0; c < nCols; c++) {\r\n                    maze.cell(r, c).visited = false;\r\n                }\r\n            }\r\n            this.removeRandomWalls(maze, 10);\r\n            return maze;\r\n        };\r\n        MazeGenerator.prototype.getNextNeighbor = function (maze, cell) {\r\n            var neighbors = [];\r\n            if (cell.row > 0) {\r\n                var left = maze.cell(cell.row - 1, cell.col);\r\n                if (!left.visited) {\r\n                    neighbors.push(left);\r\n                }\r\n            }\r\n            if (cell.row < maze.nRows - 1) {\r\n                var right = maze.cell(cell.row + 1, cell.col);\r\n                if (!right.visited) {\r\n                    neighbors.push(right);\r\n                }\r\n            }\r\n            if (cell.col > 0) {\r\n                var top_1 = maze.cell(cell.row, cell.col - 1);\r\n                if (!top_1.visited) {\r\n                    neighbors.push(top_1);\r\n                }\r\n            }\r\n            if (cell.col < maze.nCols - 1) {\r\n                var bottom = maze.cell(cell.row, cell.col + 1);\r\n                if (!bottom.visited) {\r\n                    neighbors.push(bottom);\r\n                }\r\n            }\r\n            var next = undefined;\r\n            if (neighbors.length > 0) {\r\n                var r = floor(random(0, neighbors.length));\r\n                next = neighbors[r];\r\n            }\r\n            return next;\r\n        };\r\n        MazeGenerator.prototype.removeWallsBetween = function (a, b) {\r\n            if (a.col > b.col) {\r\n                a.borders.W = false;\r\n                b.borders.E = false;\r\n            }\r\n            else if (a.col < b.col) {\r\n                a.borders.E = false;\r\n                b.borders.W = false;\r\n            }\r\n            else if (a.row > b.row) {\r\n                a.borders.N = false;\r\n                b.borders.S = false;\r\n            }\r\n            else if (a.row < b.row) {\r\n                a.borders.S = false;\r\n                b.borders.N = false;\r\n            }\r\n        };\r\n        MazeGenerator.prototype.removeRandomWalls = function (maze, n) {\r\n            for (var i = 0; i < n;) {\r\n                var r = floor(random(1, maze.nRows - 2));\r\n                var c = floor(random(1, maze.nCols - 2));\r\n                var cell = maze.cell(r, c);\r\n                var next = floor(random(0, 3));\r\n                switch (next) {\r\n                    case 0:\r\n                        if (cell.borders.N) {\r\n                            this.removeWallsBetween(cell, maze.cell(r - 1, c));\r\n                            console.log(\"remove (%d, %d) : top\", c, r);\r\n                            i++;\r\n                        }\r\n                        break;\r\n                    case 1:\r\n                        if (cell.borders.E) {\r\n                            this.removeWallsBetween(cell, maze.cell(r, c + 1));\r\n                            console.log(\"remove (%d, %d) : right\", c, r);\r\n                            i++;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        if (cell.borders.S) {\r\n                            this.removeWallsBetween(cell, maze.cell(r + 1, c));\r\n                            console.log(\"remove (%d, %d) : bottom\", c, r);\r\n                            i++;\r\n                        }\r\n                        break;\r\n                    case 3:\r\n                        if (cell.borders.W) {\r\n                            this.removeWallsBetween(cell, maze.cell(r, c - 1));\r\n                            console.log(\"remove (%d, %d) : left\", c, r);\r\n                            i++;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        };\r\n        return MazeGenerator;\r\n    }());\r\n    detail.MazeGenerator = MazeGenerator;\r\n    var CellBorders = (function () {\r\n        function CellBorders() {\r\n            this.N = true;\r\n            this.E = true;\r\n            this.S = true;\r\n            this.W = true;\r\n        }\r\n        return CellBorders;\r\n    }());\r\n    var Cell = (function () {\r\n        function Cell(row, col) {\r\n            this.visited = false;\r\n            this.row = row;\r\n            this.col = col;\r\n            this.borders = new CellBorders();\r\n        }\r\n        Cell.prototype.visit = function () {\r\n            this.visited = true;\r\n        };\r\n        return Cell;\r\n    }());\r\n    var Stair = (function () {\r\n        function Stair(row, col, up) {\r\n            this.row = row;\r\n            this.col = col;\r\n            this.up = up;\r\n        }\r\n        return Stair;\r\n    }());\r\n    detail.Stair = Stair;\r\n})(detail || (detail = {}));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/maze.ts\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}